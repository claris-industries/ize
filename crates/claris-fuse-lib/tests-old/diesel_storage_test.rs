// use serial_test::serial;
// use std::path::PathBuf;
// use tempfile::tempdir;

// // Comment out until diesel_sqlite is properly exposed
// // use claris_fuse_lib::storage::diesel_sqlite::DieselSqliteStorage;
// // use claris_fuse_lib::storage::diesel_sqlite::DieselSqliteStorageFactory;
// // use claris_fuse_lib::storage::{StorageBackend, VersionStorage, SearchableStorage};
// // use claris_fuse_lib::storage::models::{FileVersion, OperationType};

// /*
// fn setup_test_db() -> (DieselSqliteStorage, PathBuf) {
//     // Create a temporary directory for our test database
//     let temp_dir = tempdir().expect("Failed to create temporary directory");
//     let db_path = temp_dir.path().join("test.db");

//     // Create a new DieselSqliteStorage instance
//     let storage = DieselSqliteStorage::new(db_path.to_str().unwrap().to_string());

//     (storage, db_path)
// }
// */
// // Temporary placeholder until DieselSqliteStorage is properly exposed
// #[allow(dead_code)]
// fn setup_test_db() -> ((), PathBuf) {
//     // Create a temporary directory for our test database
//     let temp_dir = tempdir().expect("Failed to create temporary directory");
//     let db_path = temp_dir.path().join("test.db");

//     ((), db_path)
// }

// #[tokio::test]
// #[serial]
// async fn test_storage_init_and_close() {
//     // Temporarily skip this test
//     /*
//     let (storage, _) = setup_test_db();

//     // Initialize the storage
//     storage.init().await.expect("Failed to initialize storage");

//     // Test that the storage is initialized
//     assert_eq!(storage.name(), "diesel-sqlite");
//     assert_eq!(storage.version(), "1.0.0");

//     // Close the storage
//     storage.close().await.expect("Failed to close storage");
//     */
// }

// #[tokio::test]
// #[serial]
// async fn test_record_and_retrieve_version() {
//     // Temporarily skip this test
//     /*
//     let (storage, _) = setup_test_db();

//     // Initialize the storage
//     storage.init().await.expect("Failed to initialize storage");

//     // Create a test file content
//     let content = b"Hello, world!".to_vec();
//     let path = "/test/file.txt".to_string();
//     let description = Some("Initial version".to_string());

//     // Record a new version
//     let timestamp = SystemTime::now();
//     let version_id = storage.record_version(
//         &path,
//         OperationType::Write,
//         timestamp,
//         &content,
//         description.clone(),
//     ).await.expect("Failed to record version");

//     // Retrieve the version
//     let version = storage.get_version(&path, version_id).await
//         .expect("Failed to get version")
//         .expect("Version not found");

//     // Verify the version details
//     assert_eq!(version.path, path);
//     assert_eq!(version.operation_type, OperationType::Write);
//     assert!(version.timestamp.duration_since(UNIX_EPOCH).unwrap().as_secs() > 0);
//     assert_eq!(version.size, content.len() as u64);
//     assert_eq!(version.description, description);

//     // Retrieve and verify content
//     let retrieved_content = storage.get_version_content(&path, version_id).await
//         .expect("Failed to get version content")
//         .expect("Version content not found");

//     assert_eq!(retrieved_content, content);

//     // Close the storage
//     storage.close().await.expect("Failed to close storage");
//     */
// }

// #[tokio::test]
// #[serial]
// async fn test_multiple_versions() {
//     // Temporarily skip this test
//     /*
//     let (storage, _) = setup_test_db();

//     // Initialize the storage
//     storage.init().await.expect("Failed to initialize storage");

//     let path = "/test/multiple_versions.txt".to_string();

//     // Create multiple versions
//     for i in 1..=3 {
//         let content = format!("Content version {}", i).into_bytes();
//         let description = Some(format!("Version {}", i));

//         storage.record_version(
//             &path,
//             OperationType::Write,
//             SystemTime::now(),
//             &content,
//             description,
//         ).await.expect("Failed to record version");
//     }

//     // Get all versions for the file
//     let versions = storage.get_file_versions(&path).await
//         .expect("Failed to get file versions");

//     // Verify we have 3 versions
//     assert_eq!(versions.len(), 3);

//     // Verify versions are ordered by timestamp (latest first)
//     for i in 0..versions.len()-1 {
//         assert!(versions[i].timestamp >= versions[i+1].timestamp);
//     }

//     // Close the storage
//     storage.close().await.expect("Failed to close storage");
//     */
// }

// #[tokio::test]
// #[serial]
// async fn test_get_all_versions() {
//     // Temporarily skip this test
//     /*
//     let (storage, _) = setup_test_db();

//     // Initialize the storage
//     storage.init().await.expect("Failed to initialize storage");

//     // Create versions for multiple files
//     let paths = ["/test/file1.txt", "/test/file2.txt", "/test/file3.txt"];

//     for path in paths.iter() {
//         let content = format!("Content for {}", path).into_bytes();

//         storage.record_version(
//             path,
//             OperationType::Write,
//             SystemTime::now(),
//             &content,
//             Some(format!("Description for {}", path)),
//         ).await.expect("Failed to record version");
//     }

//     // Get all versions across all files
//     let all_versions = storage.get_versions(None).await
//         .expect("Failed to get all versions");

//     // Verify we have at least 3 versions
//     assert!(all_versions.len() >= 3);

//     // Verify each path is represented
//     for path in paths.iter() {
//         assert!(all_versions.iter().any(|v| &v.path == path));
//     }

//     // Close the storage
//     storage.close().await.expect("Failed to close storage");
//     */
// }

// #[tokio::test]
// #[serial]
// async fn test_search_versions() {
//     // Temporarily skip this test
//     /*
//     let (storage, _) = setup_test_db();

//     // Initialize the storage
//     storage.init().await.expect("Failed to initialize storage");

//     let path = "/test/searchable.txt".to_string();
//     let content = b"Searchable content".to_vec();

//     // Record versions with searchable descriptions
//     let descriptions = [
//         "This is a unique apple description",
//         "This contains banana and pineapple",
//         "Nothing special here"
//     ];

//     for desc in descriptions.iter() {
//         storage.record_version(
//             &path,
//             OperationType::Write,
//             SystemTime::now(),
//             &content,
//             Some(desc.to_string()),
//         ).await.expect("Failed to record version");
//     }

//     // Search for "apple"
//     let apple_results = storage.search_versions_by_description("apple").await
//         .expect("Failed to search versions");

//     // Should match "apple" and "pineapple"
//     assert_eq!(apple_results.len(), 2);

//     // Search for "unique"
//     let unique_results = storage.search_versions_by_description("unique").await
//         .expect("Failed to search versions");

//     assert_eq!(unique_results.len(), 1);
//     assert!(unique_results[0].description.as_ref().unwrap().contains("unique"));

//     // Close the storage
//     storage.close().await.expect("Failed to close storage");
//     */
// }

// #[tokio::test]
// #[serial]
// async fn test_update_description() {
//     // Temporarily skip this test
//     /*
//     let (storage, _) = setup_test_db();

//     // Initialize the storage
//     storage.init().await.expect("Failed to initialize storage");

//     let path = "/test/update_desc.txt".to_string();
//     let content = b"Content for description update test".to_vec();

//     // Record a version
//     let version_id = storage.record_version(
//         &path,
//         OperationType::Write,
//         SystemTime::now(),
//         &content,
//         Some("Initial description".to_string()),
//     ).await.expect("Failed to record version");

//     // Update the description
//     let new_description = "Updated description";
//     storage.update_description(&path, version_id, new_description.to_string())
//         .await.expect("Failed to update description");

//     // Retrieve the version and verify the updated description
//     let updated_version = storage.get_version(&path, version_id).await
//         .expect("Failed to get version")
//         .expect("Version not found");

//     assert_eq!(updated_version.description, Some(new_description.to_string()));

//     // Close the storage
//     storage.close().await.expect("Failed to close storage");
//     */
// }

// #[tokio::test]
// #[serial]
// async fn test_storage_factory() {
//     // Temporarily skip this test
//     /*
//     // Create a temporary directory for our test database
//     let temp_dir = tempdir().expect("Failed to create temporary directory");
//     let db_path = temp_dir.path().join("factory_test.db").to_str().unwrap().to_string();

//     // Create a factory with custom pool size
//     let factory = DieselSqliteStorageFactory::with_pool_size(db_path, 2);

//     // Create a storage instance using the factory
//     let storage = factory.create_storage().await;

//     // Initialize the storage
//     storage.init().await.expect("Failed to initialize storage");

//     // Test that the storage is working
//     assert_eq!(storage.name(), "diesel-sqlite");

//     // Create a searchable storage instance using the factory
//     let searchable_storage = factory.create_searchable_storage().await;

//     // Initialize the searchable storage
//     searchable_storage.init().await.expect("Failed to initialize searchable storage");

//     // Test recording and searching
//     let path = "/factory/test.txt".to_string();
//     let content = b"Factory test content".to_vec();

//     searchable_storage.record_version(
//         &path,
//         OperationType::Write,
//         SystemTime::now(),
//         &content,
//         Some("Factory searchable description".to_string()),
//     ).await.expect("Failed to record version");

//     let search_results = searchable_storage.search_versions_by_description("factory")
//         .await.expect("Failed to search");

//     assert_eq!(search_results.len(), 1);

//     // Close the storages
//     storage.close().await.expect("Failed to close storage");
//     searchable_storage.close().await.expect("Failed to close searchable storage");
//     */
// }
